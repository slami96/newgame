<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced Brick Breaker</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            background-color: #0a0a2a;
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            color: white;
        }
        #game-container {
            position: relative;
            width: 800px;
            height: 600px;
        }
        canvas {
            background-color: #111133;
            box-shadow: 0 0 20px rgba(0, 0, 255, 0.5);
            border-radius: 10px;
        }
        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #00ffff;
        }
        #lives {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #ff00ff;
        }
        #combo-display {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #ffaa00;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 0 0 5px #ff7700;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #level-display {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 0 0 5px #00ffff;
        }
        #game-over, #level-complete {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            font-size: 36px;
            display: none;
            border-radius: 10px;
            text-align: center;
        }
        #game-over h2, #level-complete h2 {
            color: #ff5555;
            text-shadow: 0 0 10px #ff0000;
            margin-bottom: 10px;
        }
        #game-stats {
            margin: 20px 0;
            font-size: 24px;
            color: #aaffff;
        }
        button {
            padding: 15px 30px;
            font-size: 20px;
            background: linear-gradient(to bottom, #4444ff, #2222aa);
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-top: 20px;
            box-shadow: 0 0 10px rgba(0, 255, 255, 0.5);
            transition: all 0.3s;
        }
        button:hover {
            background: linear-gradient(to bottom, #5555ff, #3333bb);
            transform: scale(1.05);
        }
        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(10, 10, 42, 0.9);
            color: white;
            border-radius: 10px;
            z-index: 100;
        }
        #start-screen h1 {
            font-size: 48px;
            margin-bottom: 30px;
            text-shadow: 0 0 15px #00ffff;
            animation: glow 2s infinite alternate;
        }
        @keyframes glow {
            from {
                text-shadow: 0 0 10px #00ffff;
            }
            to {
                text-shadow: 0 0 20px #00ffff, 0 0 30px #00ffff;
            }
        }
        #instructions {
            margin: 20px 0;
            text-align: center;
            max-width: 500px;
            line-height: 1.5;
        }
        #fps {
            position: absolute;
            bottom: 10px;
            right: 10px;
            color: rgba(255, 255, 255, 0.5);
            font-size: 12px;
        }
        #pause-indicator {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 36px;
            background-color: rgba(0, 0, 0, 0.7);
            padding: 20px 40px;
            border-radius: 10px;
            display: none;
            z-index: 50;
        }
        #debug-panel {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            font-size: 12px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px;
            border-radius: 5px;
            max-width: 300px;
            display: none; /* Set to block if DEBUG_MODE is true */
        }
        /* Theme selector */
        #theme-selector {
            position: absolute;
            top: 15px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 10px;
            z-index: 110;
        }
        .theme-btn {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 2px solid white;
            cursor: pointer;
            transition: transform 0.2s;
        }
        .theme-btn:hover {
            transform: scale(1.2);
        }
        .theme-btn.active {
            border: 2px solid gold;
            box-shadow: 0 0 10px gold;
        }
        #standard-theme {
            background: linear-gradient(to bottom right, #0a0a2a, #191970);
        }
        #neon-theme {
            background: linear-gradient(to bottom right, #000, #440044);
        }
        #retro-theme {
            background: linear-gradient(to bottom right, #221, #442);
        }
        /* High Score display */
        #high-scores {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.9);
            color: white;
            font-size: 24px;
            display: none;
            border-radius: 10px;
            z-index: 120;
        }
        #high-scores h2 {
            font-size: 36px;
            margin-bottom: 20px;
            text-shadow: 0 0 10px #00ffff;
        }
        #scores-list {
            width: 80%;
            margin-bottom: 30px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            padding: 10px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
        }
        .score-row:nth-child(even) {
            background-color: rgba(255, 255, 255, 0.05);
        }
        /* Animated elements */
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-20px); }
        }
        @keyframes flash {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        @keyframes shake {
            0%, 100% { transform: translateX(0); }
            10%, 30%, 50%, 70%, 90% { transform: translateX(-5px); }
            20%, 40%, 60%, 80% { transform: translateX(5px); }
        }
        .shaking {
            animation: shake 0.5s;
        }
        /* Screen flash */
        #screen-flash {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: white;
            opacity: 0;
            pointer-events: none;
            border-radius: 10px;
            transition: opacity 0.1s;
        }
        /* Mobile controls */
        #mobile-controls {
            position: absolute;
            bottom: 0;
            left: 0;
            width: 100%;
            height: 80px;
            display: none; /* Will be set to flex by JS if mobile */
            justify-content: space-between;
            align-items: center;
            z-index: 30;
        }
        .mobile-btn {
            width: 40%;
            height: 100%;
            background-color: rgba(255, 255, 255, 0.1);
            display: flex;
            justify-content: center;
            align-items: center;
            font-size: 24px;
            cursor: pointer;
            user-select: none;
        }
        #menu-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            background-color: rgba(0, 0, 0, 0.5);
            border-radius: 50%;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            z-index: 110;
        }
        #menu-btn::before {
            content: "⚙️";
            font-size: 20px;
        }
        #game-menu {
            position: absolute;
            top: 70px;
            right: 20px;
            background-color: rgba(0, 0, 0, 0.8);
            border-radius: 10px;
            padding: 10px;
            display: none;
            z-index: 110;
        }
        .menu-item {
            padding: 10px;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        .menu-item:hover {
            background-color: rgba(255, 255, 255, 0.1);
        }
        #name-input {
            padding: 10px;
            font-size: 18px;
            border-radius: 5px;
            border: none;
            margin: 10px 0;
            width: 250px;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="gameCanvas" width="800" height="600"></canvas>
        <div id="score">Score: 0</div>
        <div id="lives">Lives: 3</div>
        <div id="combo-display">Combo x1</div>
        <div id="level-display">Level 1</div>
        <div id="fps">FPS: 0</div>
        <div id="debug-panel"></div>

        <div id="screen-flash"></div>
        <div id="menu-btn"></div>
        <div id="game-menu">
            <div class="menu-item" id="toggle-sound">Sound: ON</div>
            <div class="menu-item" id="toggle-music">Music: ON</div>
            <div class="menu-item" id="show-high-scores">High Scores</div>
            <div class="menu-item" id="toggle-fullscreen">Fullscreen</div>
            <div class="menu-item" id="restart-from-menu">Restart</div>
        </div>

        <div id="theme-selector">
            <div class="theme-btn active" id="standard-theme" title="Standard Theme"></div>
            <div class="theme-btn" id="neon-theme" title="Neon Theme"></div>
            <div class="theme-btn" id="retro-theme" title="Retro Theme"></div>
        </div>
        <div id="start-screen">
            <h1>BRICK BREAKER</h1>
            <div id="instructions">
                 <p>Use your mouse or arrow keys to move the paddle and bounce the ball to break all bricks.</p>
                 <p>Don't let the ball fall off the bottom of the screen!</p>
                 <p>Some bricks need multiple hits to break!</p>
                 <p>Watch for special power-ups!</p>
                 <p>Press 'P' to pause the game at any time.</p>
            </div>
            <button id="start-button">START GAME</button>
            <button id="high-scores-button">HIGH SCORES</button>
        </div>
        <div id="high-scores">
            <h2>HIGH SCORES</h2>
            <div id="scores-list">
            </div>
            <button id="back-button">BACK</button>
        </div>
        <div id="game-over">
            <h2>GAME OVER</h2>
            <div id="final-score"></div>
            <div id="game-stats"></div>
            <div id="new-high-score" style="color: gold; font-size: 24px; margin: 10px 0; display: none;">
                NEW HIGH SCORE!
            </div>
            <input type="text" id="name-input" placeholder="Enter your name" style="display: none;">
            <button id="save-score-button" style="display: none;">SAVE SCORE</button>
            <button id="restart-button">PLAY AGAIN</button>
            <button id="show-scores-button">HIGH SCORES</button>
        </div>
        <div id="level-complete">
            <h2>LEVEL COMPLETE!</h2>
            <div id="level-score"></div>
            <div id="level-stats"></div>
            <button id="next-level-button">NEXT LEVEL</button>
        </div>
        <div id="pause-indicator">PAUSED</div>
        <div id="mobile-controls">
            <div class="mobile-btn" id="left-btn">◀</div>
            <div class="mobile-btn" id="right-btn">▶</div>
        </div>
    </div>

    <script>
        // Debug mode - set to false for production, true for troubleshooting
        const DEBUG_MODE = true; // Set to true to see debug messages in console

        // Game constants
        const PADDLE_HEIGHT = 20;
        let PADDLE_WIDTH = 100; // Initial width, can be changed by power-up
        const BALL_RADIUS = 10;
        const BRICK_ROWS = 5;
        const BRICK_COLUMNS = 10;
        const BRICK_HEIGHT = 30;
        const BRICK_WIDTH = 75;
        const BRICK_PADDING = 5;
        const BRICK_OFFSET_TOP = 80;
        const BRICK_OFFSET_LEFT = 15;

        // Game variables
        let canvas, ctx, scoreDisplay, livesDisplay, levelDisplay, comboDisplay,
            fpsDisplay, gameOverScreen, levelCompleteScreen, startScreen,
            pauseIndicator, finalScoreDisplay, gameStatsDisplay, levelScoreDisplay,
            levelStatsDisplay, debugPanel, screenFlash;

        let paddleX = 0;
        let ballX = 0; // Initial ball position (updated in initializeElements)
        let ballY = 0; // Initial ball position (updated in initializeElements)
        let ballSpeedX = 4; // Initial speed (can be modified)
        let ballSpeedY = -4; // Initial speed (can be modified)
        let rightPressed = false;
        let leftPressed = false;
        let score = 0;
        let lives = 3;
        let level = 1;
        let combo = 0;
        let maxCombo = 0;
        let comboTimer = 0; // Frames remaining for combo
        let gameStarted = false;
        let gamePaused = false;
        let bricksHit = 0; // Counts destroyed hit points for level progress
        let totalBricks = 0; // Total hit points required to clear level
        let paddleHits = 0; // Stat for game over/level complete screen
        let gameTime = 0; // Total time played in milliseconds
        let startTime = 0; // Timestamp when the game starts/restarts
        let lastFrameTime = 0; // For calculating delta time
        let frameCount = 0; // For FPS calculation
        let fps = 0;
        let lastFpsUpdate = 0; // For FPS calculation timing
        let soundEnabled = true;
        let musicEnabled = true;
        let currentTheme = 'standard';
        let screenShaking = false; // Flag to prevent overlapping shake animations
        let backgroundMusic = null; // Audio context object
        let multiballActive = false; // Flag for multiball state
        let balls = []; // Array to hold all ball objects

        // Store the various themes
        const themes = {
            standard: {
                background: { start: '#000033', end: '#000022' },
                paddle: { start: '#4444ff', end: '#2222aa' },
                ball: { start: '#ffffff', end: '#aaaaff' },
                brick: { 0: '#FF5555', 1: '#FFAA55', 2: '#FFFF55', 3: '#55FF55', 4: '#55FFFF' },
                particles: { paddle: '#4444ff', wall: '#ffffff' },
                screen: { bg: 'rgba(10, 10, 42, 0.9)' }
            },
            neon: {
                background: { start: '#000000', end: '#110011' },
                paddle: { start: '#ff00ff', end: '#aa00aa' },
                ball: { start: '#ffffff', end: '#ff88ff' },
                brick: { 0: '#ff0066', 1: '#ff3300', 2: '#ffcc00', 3: '#33ff00', 4: '#00ffcc' },
                particles: { paddle: '#ff00ff', wall: '#00ffff' },
                screen: { bg: 'rgba(17, 0, 17, 0.9)' }
            },
            retro: {
                background: { start: '#222211', end: '#111100' },
                paddle: { start: '#cccc44', end: '#aaaa22' },
                ball: { start: '#ffffff', end: '#eeeebb' },
                brick: { 0: '#cc4400', 1: '#ccaa00', 2: '#44cc00', 3: '#00ccaa', 4: '#0044cc' },
                particles: { paddle: '#cccc44', wall: '#ffffff' },
                screen: { bg: 'rgba(34, 34, 17, 0.9)' }
            }
        };

        // Power-up variables
        const paddleWidthNormal = PADDLE_WIDTH;
        const paddleWidthWide = PADDLE_WIDTH * 1.5;
        const ballSpeedNormal = 4; // Base speed, actual speed increases over time/levels
        const ballSpeedSlow = 2; // Speed during slowBall power-up
        let powerupActive = false; // Is any timed power-up active?
        let powerupTimer = 0; // Frames remaining for active power-up
        let activePowerupType = null; // Type of the currently active timed power-up

        // Create arrays for game objects
        let bricks = [];
        let stars = []; // For background effect
        let particles = []; // For visual effects on collision
        let powerups = []; // Falling power-up items
        let highScores = []; // Array to store high score objects { name, score, level }

        // Debug function
        function debug(message) {
            if (DEBUG_MODE && debugPanel) {
                const timestamp = new Date().toLocaleTimeString();
                debugPanel.innerHTML += `[${timestamp}] ${message}<br>`;
                // Keep only the last N messages to prevent overflow
                const lines = debugPanel.innerHTML.split("<br>");
                const maxLines = 10;
                if (lines.length > maxLines + 1) { // +1 because split leaves an empty element at the end
                    debugPanel.innerHTML = lines.slice(lines.length - (maxLines + 1)).join("<br>");
                }
                // Scroll to bottom
                debugPanel.scrollTop = debugPanel.scrollHeight;
            }
             // Also log to the regular console
             console.log(message);
        }

        // Load high scores from local storage
        function loadHighScores() {
            const savedScores = localStorage.getItem('brickBreakerHighScores');
            if (savedScores) {
                try {
                    highScores = JSON.parse(savedScores);
                    debug("Loaded high scores from local storage");
                } catch (e) {
                    debug("Error loading high scores: " + e.message + ". Resetting scores.");
                    highScores = [];
                    // Initialize with default scores if parsing fails
                    initializeDefaultHighScores();
                }
            } else {
                 debug("No saved scores found. Initializing default scores.");
                 initializeDefaultHighScores();
            }
             // Ensure highScores is always sorted
             highScores.sort((a, b) => b.score - a.score);
        }

         // Function to set default high scores if none exist or loading fails
         function initializeDefaultHighScores() {
             highScores = [
                 { name: "AAA", score: 5000, level: 3 },
                 { name: "BBB", score: 3500, level: 2 },
                 { name: "CCC", score: 2000, level: 2 },
                 { name: "DDD", score: 1000, level: 1 },
                 { name: "EEE", score: 500, level: 1 }
             ];
             saveHighScores(); // Save defaults immediately
         }


        // Save high scores to local storage
        function saveHighScores() {
            try {
                // Ensure scores are sorted before saving
                highScores.sort((a, b) => b.score - a.score);
                localStorage.setItem('brickBreakerHighScores', JSON.stringify(highScores));
                debug("Saved high scores to local storage");
            } catch (e) {
                debug("Error saving high scores: " + e.message);
            }
        }

        // Check if score qualifies for high score list
        function isHighScore(currentScore) {
            // Qualifies if list has < 10 entries OR score is higher than the lowest score on the full list
            return highScores.length < 10 || currentScore > highScores[highScores.length - 1].score;
        }

        // Add a new high score
        function addHighScore(name, currentScore, currentLevel) {
             const newEntry = { name: name, score: currentScore, level: currentLevel };
             debug(`Adding high score: ${name} - ${currentScore} (Level ${currentLevel})`);
             highScores.push(newEntry);
             highScores.sort((a, b) => b.score - a.score); // Sort descending by score
             if (highScores.length > 10) {
                 highScores = highScores.slice(0, 10); // Keep only top 10
             }
             saveHighScores();
        }

        // Display high scores on the high score screen
        function displayHighScores() {
            const scoresList = document.getElementById('scores-list');
            if (!scoresList) {
                 debug("Error: scores-list element not found for display.");
                 return;
             }
            scoresList.innerHTML = ''; // Clear previous list
            if (highScores.length === 0) {
                scoresList.innerHTML = '<div class="score-row">No high scores yet!</div>';
                return;
            }
            highScores.forEach((scoreData, index) => {
                const row = document.createElement('div');
                row.className = 'score-row';
                // Sanitize name before displaying
                const safeName = String(scoreData.name || '???').replace(/</g, "&lt;").replace(/>/g, "&gt;");
                row.innerHTML = `
                    <span>${index + 1}. ${safeName}</span>
                    <span>${scoreData.score} (Level ${scoreData.level})</span>
                `;
                scoresList.appendChild(row);
            });
        }

        // Initialize all DOM elements safely
        function initializeElements() {
            debug("Initializing DOM elements...");
            try {
                canvas = document.getElementById("gameCanvas");
                ctx = canvas?.getContext("2d"); // Use optional chaining
                scoreDisplay = document.getElementById("score");
                livesDisplay = document.getElementById("lives");
                levelDisplay = document.getElementById("level-display");
                comboDisplay = document.getElementById("combo-display");
                fpsDisplay = document.getElementById("fps");
                gameOverScreen = document.getElementById("game-over");
                levelCompleteScreen = document.getElementById("level-complete");
                startScreen = document.getElementById("start-screen");
                pauseIndicator = document.getElementById("pause-indicator");
                finalScoreDisplay = document.getElementById("final-score");
                gameStatsDisplay = document.getElementById("game-stats");
                levelScoreDisplay = document.getElementById("level-score");
                levelStatsDisplay = document.getElementById("level-stats");
                debugPanel = document.getElementById("debug-panel");
                screenFlash = document.getElementById("screen-flash");

                 // Check if essential elements exist
                 if (!canvas || !ctx || !scoreDisplay || !livesDisplay || !levelDisplay || !gameOverScreen || !startScreen) {
                     console.error("Critical DOM elements missing!");
                     debug("Error: Critical DOM elements missing! Cannot initialize.");
                     return false;
                 }

                if (DEBUG_MODE && debugPanel) {
                    debugPanel.style.display = "block";
                }

                // Set initial paddle and ball positions relative to canvas size
                paddleX = (canvas.width - PADDLE_WIDTH) / 2;
                ballX = canvas.width / 2;
                ballY = canvas.height - PADDLE_HEIGHT - BALL_RADIUS - 10;

                // Initialize the first ball in the balls array
                balls = [{
                    x: ballX,
                    y: ballY,
                    speedX: ballSpeedX,
                    speedY: ballSpeedY,
                    radius: BALL_RADIUS,
                    fireball: false // Fireball status specific to each ball
                }];

                debug("DOM elements initialized successfully!");
                return true;
            } catch (e) {
                debug("Error initializing elements: " + e.message);
                console.error("Error initializing elements:", e);
                return false;
            }
        }

        // Create bricks for the current level
        function createBricks() {
            bricks = [];
            totalBricks = 0; // Reset count for the new level
            for (let c = 0; c < BRICK_COLUMNS; c++) {
                bricks[c] = [];
                for (let r = 0; r < BRICK_ROWS; r++) {
                    // Determine if this should be a special brick (more common in higher levels)
                    let specialChance = 0.05 + (level - 1) * 0.05; // 5% base + 5% per level
                    let isSpecial = Math.random() < specialChance;
                    let hitPoints = isSpecial ? (2 + Math.floor(Math.random() * level)) : 1;
                    hitPoints = Math.min(hitPoints, 3); // Cap at 3 hits max

                    // Get color based on row and theme
                     const colorIndex = r % Object.keys(themes[currentTheme].brick).length;
                     const brickColor = themes[currentTheme].brick[colorIndex];


                    bricks[c][r] = {
                        x: 0, // Position calculated during drawing
                        y: 0, // Position calculated during drawing
                        status: hitPoints, // Remaining hits
                        maxHits: hitPoints, // Original hits for color calculation
                        color: brickColor || '#CCCCCC', // Fallback color
                        special: isSpecial,
                        moving: false, // Default: not moving
                        moveDir: 1, // Default direction if moving
                        moveSpeed: 1 // Default speed if moving
                    };
                     totalBricks += hitPoints; // Sum total hit points needed
                }
            }

            // Add moving bricks in higher levels (level 3+)
            if (level >= 3) {
                let movingRow = Math.floor(Math.random() * BRICK_ROWS);
                 let moveSpeed = 0.5 + (level - 3) * 0.2; // Speed increases slightly with level
                for (let c = 0; c < BRICK_COLUMNS; c++) {
                     if (bricks[c]?.[movingRow]) { // Check if brick exists
                        bricks[c][movingRow].moving = true;
                        bricks[c][movingRow].moveDir = c % 2 === 0 ? 1 : -1; // Alternate direction
                        bricks[c][movingRow].moveSpeed = moveSpeed;
                     }
                }
                debug(`Added moving bricks in row ${movingRow + 1} with speed ${moveSpeed.toFixed(1)}`);
            }
            bricksHit = 0; // Reset destroyed brick count for the level
            debug(`Created ${BRICK_COLUMNS * BRICK_ROWS} physical bricks (${totalBricks} hit points total) for Level ${level}`);
        }


         // --- Drawing Functions ---

        function drawBall() {
            balls.forEach(ball => {
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);

                let ballGradient = ctx.createRadialGradient(
                    ball.x - ball.radius / 3, ball.y - ball.radius / 3, 0,
                    ball.x, ball.y, ball.radius
                );
                ballGradient.addColorStop(0, themes[currentTheme].ball.start);
                ballGradient.addColorStop(1, themes[currentTheme].ball.end);
                ctx.fillStyle = ballGradient;
                ctx.fill();
                ctx.closePath();

                // Ball glow effect
                ctx.beginPath();
                ctx.arc(ball.x, ball.y, ball.radius + 3, 0, Math.PI * 2);
                ctx.strokeStyle = "rgba(100, 100, 255, 0.3)";
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.closePath();

                // Fireball effect overlay
                if (ball.fireball) {
                    ctx.beginPath();
                    ctx.arc(ball.x, ball.y, ball.radius + 5, 0, Math.PI * 2);
                    let flameGradient = ctx.createRadialGradient(
                        ball.x, ball.y, ball.radius,
                        ball.x, ball.y, ball.radius + 5
                    );
                    flameGradient.addColorStop(0, "rgba(255, 100, 0, 0.8)");
                    flameGradient.addColorStop(1, "rgba(255, 50, 0, 0)");
                    ctx.fillStyle = flameGradient;
                    ctx.fill();
                    ctx.closePath();
                }
            });
        }

        function drawPaddle() {
            ctx.beginPath();
            let paddleGradient = ctx.createLinearGradient(
                paddleX, canvas.height - PADDLE_HEIGHT,
                paddleX, canvas.height
            );
            paddleGradient.addColorStop(0, themes[currentTheme].paddle.start);
            paddleGradient.addColorStop(1, themes[currentTheme].paddle.end);

            // Draw main paddle with rounded corners (fallback if not supported)
            if (ctx.roundRect) {
                ctx.roundRect(paddleX, canvas.height - PADDLE_HEIGHT, PADDLE_WIDTH, PADDLE_HEIGHT, [5, 5, 0, 0]);
            } else {
                ctx.rect(paddleX, canvas.height - PADDLE_HEIGHT, PADDLE_WIDTH, PADDLE_HEIGHT);
            }
            ctx.fillStyle = paddleGradient;
            ctx.fill();
            ctx.closePath(); // Close path for main paddle

            // Draw paddle highlight
            ctx.beginPath();
            if (ctx.roundRect) {
                ctx.roundRect(paddleX + 5, canvas.height - PADDLE_HEIGHT + 3, PADDLE_WIDTH - 10, PADDLE_HEIGHT / 3, [3, 3, 0, 0]);
            } else {
                ctx.rect(paddleX + 5, canvas.height - PADDLE_HEIGHT + 3, PADDLE_WIDTH - 10, PADDLE_HEIGHT / 3);
            }
            ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
            ctx.fill();
            ctx.closePath(); // Close path for highlight

            // Paddle glow effect
             ctx.beginPath();
             if (ctx.roundRect) {
                 ctx.roundRect(paddleX - 2, canvas.height - PADDLE_HEIGHT - 1, PADDLE_WIDTH + 4, PADDLE_HEIGHT + 2, [7, 7, 0, 0]);
             } else {
                 ctx.rect(paddleX - 2, canvas.height - PADDLE_HEIGHT - 1, PADDLE_WIDTH + 4, PADDLE_HEIGHT + 2);
             }
             ctx.strokeStyle = "rgba(100, 100, 255, 0.5)";
             ctx.lineWidth = 2;
             ctx.stroke();
             ctx.closePath(); // Close path for glow
        }


        function drawBricks() {
            for (let c = 0; c < BRICK_COLUMNS; c++) {
                for (let r = 0; r < BRICK_ROWS; r++) {
                     const brick = bricks[c]?.[r]; // Use optional chaining
                     if (!brick || brick.status <= 0) continue; // Skip if brick doesn't exist or is broken

                    let brickX = c * (BRICK_WIDTH + BRICK_PADDING) + BRICK_OFFSET_LEFT;
                    let brickY = r * (BRICK_HEIGHT + BRICK_PADDING) + BRICK_OFFSET_TOP;

                    // Update position for moving bricks
                    if (brick.moving) {
                         // Simple horizontal oscillation using sine wave based on game time
                         const moveOffset = Math.sin(gameTime / 1000 * Math.PI * brick.moveSpeed) * 20; // Oscillate 20px
                         brickX += moveOffset * brick.moveDir;

                         // Optional: Keep moving bricks within canvas bounds (simple clamp)
                         brickX = Math.max(BRICK_OFFSET_LEFT, Math.min(canvas.width - BRICK_WIDTH - BRICK_OFFSET_LEFT, brickX));
                    }

                    // Store calculated position back into the brick object
                    brick.x = brickX;
                    brick.y = brickY;

                     // Adjust color based on hit points remaining relative to max hits
                     const hitRatio = brick.maxHits > 0 ? brick.status / brick.maxHits : 1;
                     const baseColor = adjustColorBrightness(brick.color, hitRatio * 100); // Darken based on damage

                     // Create gradient for brick
                    let brickGradient = ctx.createLinearGradient(brickX, brickY, brickX, brickY + BRICK_HEIGHT);
                    let lighterColor = lightenColor(baseColor, 30);
                    let darkerColor = darkenColor(baseColor, 30);
                    brickGradient.addColorStop(0, lighterColor);
                    brickGradient.addColorStop(1, darkerColor);


                    // Draw main brick
                     ctx.beginPath();
                    if (ctx.roundRect) {
                        ctx.roundRect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT, 5);
                    } else {
                        ctx.rect(brickX, brickY, BRICK_WIDTH, BRICK_HEIGHT);
                    }
                     ctx.fillStyle = brickGradient;
                     ctx.fill();
                     ctx.closePath();


                    // Draw brick highlight
                     ctx.beginPath();
                    if (ctx.roundRect) {
                        ctx.roundRect(brickX + 3, brickY + 3, BRICK_WIDTH - 6, BRICK_HEIGHT / 3, [3, 3, 0, 0]);
                    } else {
                        ctx.rect(brickX + 3, brickY + 3, BRICK_WIDTH - 6, BRICK_HEIGHT / 3);
                    }
                    ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                    ctx.fill();
                     ctx.closePath();


                    // Brick glow effect (subtle outline)
                    ctx.beginPath();
                     if (ctx.roundRect) {
                        ctx.roundRect(brickX - 1, brickY - 1, BRICK_WIDTH + 2, BRICK_HEIGHT + 2, 6);
                    } else {
                        ctx.rect(brickX - 1, brickY - 1, BRICK_WIDTH + 2, BRICK_HEIGHT + 2);
                    }
                    ctx.strokeStyle = "rgba(255, 255, 255, 0.1)"; // Make it more subtle
                    ctx.lineWidth = 1;
                    ctx.stroke();
                     ctx.closePath();


                    // Draw hit points indicator for multi-hit bricks
                    if (brick.maxHits > 1) {
                        ctx.font = "bold 14px Arial"; // Slightly smaller font
                        ctx.textAlign = "center";
                        ctx.textBaseline = "middle";
                         ctx.fillStyle = "rgba(255, 255, 255, 0.8)"; // White indicator text
                         // Add a subtle shadow for readability
                         ctx.shadowColor = "rgba(0, 0, 0, 0.7)";
                         ctx.shadowBlur = 3;
                         ctx.shadowOffsetX = 1;
                         ctx.shadowOffsetY = 1;
                         ctx.fillText(brick.status, brickX + BRICK_WIDTH / 2, brickY + BRICK_HEIGHT / 2 + 1); // Offset slightly for centering
                         // Reset shadow
                         ctx.shadowColor = "transparent";
                         ctx.shadowBlur = 0;
                         ctx.shadowOffsetX = 0;
                         ctx.shadowOffsetY = 0;
                    }
                }
            }
        }

         // --- Utility Color Functions ---

        function adjustColorBrightness(hexColor, percent) {
            // Ensure hexColor is a valid string
            if (typeof hexColor !== 'string' || hexColor.charAt(0) !== '#') {
                return '#CCCCCC'; // Return a default gray if color is invalid
            }
            // Clamp percent between 0 and 100
            percent = Math.max(0, Math.min(100, percent));
            let r = parseInt(hexColor.substring(1, 3), 16);
            let g = parseInt(hexColor.substring(3, 5), 16);
            let b = parseInt(hexColor.substring(5, 7), 16);
            r = Math.round(r * (percent / 100));
            g = Math.round(g * (percent / 100));
            b = Math.round(b * (percent / 100));
             // Ensure values are within 0-255 and pad correctly
             const rHex = Math.max(0, Math.min(255, r)).toString(16).padStart(2, '0');
             const gHex = Math.max(0, Math.min(255, g)).toString(16).padStart(2, '0');
             const bHex = Math.max(0, Math.min(255, b)).toString(16).padStart(2, '0');
             return `#${rHex}${gHex}${bHex}`;
        }

        function lightenColor(hexColor, percent) {
             if (typeof hexColor !== 'string' || hexColor.charAt(0) !== '#') {
                 return '#EEEEEE';
             }
             percent = Math.max(0, Math.min(100, percent));
            let r = parseInt(hexColor.substring(1, 3), 16);
            let g = parseInt(hexColor.substring(3, 5), 16);
            let b = parseInt(hexColor.substring(5, 7), 16);
            r = Math.round(r + (255 - r) * (percent / 100));
            g = Math.round(g + (255 - g) * (percent / 100));
            b = Math.round(b + (255 - b) * (percent / 100));
             const rHex = Math.max(0, Math.min(255, r)).toString(16).padStart(2, '0');
             const gHex = Math.max(0, Math.min(255, g)).toString(16).padStart(2, '0');
             const bHex = Math.max(0, Math.min(255, b)).toString(16).padStart(2, '0');
            return `#${rHex}${gHex}${bHex}`;
        }

        function darkenColor(hexColor, percent) {
            if (typeof hexColor !== 'string' || hexColor.charAt(0) !== '#') {
                 return '#333333';
             }
             percent = Math.max(0, Math.min(100, percent));
            let r = parseInt(hexColor.substring(1, 3), 16);
            let g = parseInt(hexColor.substring(3, 5), 16);
            let b = parseInt(hexColor.substring(5, 7), 16);
            r = Math.round(r - (r * (percent / 100)));
            g = Math.round(g - (g * (percent / 100)));
            b = Math.round(b - (b * (percent / 100)));
             const rHex = Math.max(0, Math.min(255, r)).toString(16).padStart(2, '0');
             const gHex = Math.max(0, Math.min(255, g)).toString(16).padStart(2, '0');
             const bHex = Math.max(0, Math.min(255, b)).toString(16).padStart(2, '0');
            return `#${rHex}${gHex}${bHex}`;
        }

         // --- Input Handlers ---

        function keyDownHandler(e) {
             // Ignore input if game isn't active or if an overlay screen is visible
             if (!gameStarted || gamePaused || gameOverScreen.style.display === 'flex' || levelCompleteScreen.style.display === 'flex' || highScores.style.display === 'flex') {
                 // Exception: Allow 'Enter' on high score name input
                 if (!(e.key === 'Enter' && document.getElementById('name-input')?.style.display === 'block')) {
                     return;
                 }
             }

             // Handle high score name input submission
             if (e.key === 'Enter' && document.getElementById('save-score-button')?.style.display === 'block') {
                 document.getElementById('save-score-button').click(); // Trigger save button click
                 e.preventDefault(); // Prevent default Enter behavior (like form submission)
                 return;
             }

            if (e.key === "Right" || e.key === "ArrowRight") {
                rightPressed = true;
                 // debug("Right key pressed, rightPressed = " + rightPressed);
                e.preventDefault();
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                leftPressed = true;
                 // debug("Left key pressed, leftPressed = " + leftPressed);
                e.preventDefault();
            } else if (e.key === "p" || e.key === "P") {
                // Allow pausing only if game is running and no overlay is shown
                 if (gameStarted && !gamePaused && gameOverScreen.style.display !== 'flex' && levelCompleteScreen.style.display !== 'flex' && highScores.style.display !== 'flex') {
                     togglePause();
                     e.preventDefault();
                 }
            } else if (e.key === "d" || e.key === "D") {
                // Toggle debug panel visibility with 'D' key
                if (debugPanel) {
                     const currentDisplay = debugPanel.style.display;
                    debugPanel.style.display = currentDisplay === "none" ? "block" : "none";
                    debug(`Debug panel toggled ${debugPanel.style.display === 'block' ? 'ON' : 'OFF'}`);
                }
            } else if (e.key === "m" || e.key === "M") {
                toggleMusic(); // Allow toggling music anytime
            } else if (e.key === "s" || e.key === "S") {
                toggleSound(); // Allow toggling sound anytime
            } else if (e.key === "f" || e.key === "F") {
                toggleFullscreen(); // Allow toggling fullscreen anytime
            }
        }

        function keyUpHandler(e) {
            if (e.key === "Right" || e.key === "ArrowRight") {
                rightPressed = false;
                 // debug("Right key released, rightPressed = " + rightPressed);
            } else if (e.key === "Left" || e.key === "ArrowLeft") {
                leftPressed = false;
                 // debug("Left key released, leftPressed = " + leftPressed);
            }
        }

        function mouseMoveHandler(e) {
            // Allow mouse control only if game is active and not paused/over
            if (!gameStarted || gamePaused || gameOverScreen.style.display === 'flex' || levelCompleteScreen.style.display === 'flex') {
                 // Optional: Log why mouse move is ignored if debugging
                 // if (DEBUG_MODE) {
                 //     debug("Mouse move ignored: gameStarted=" + gameStarted + ", gamePaused=" + gamePaused + ", gameOver=" + (gameOverScreen.style.display === 'flex'));
                 // }
                 return;
            }

            let relativeX;
            try {
                 const rect = canvas.getBoundingClientRect();
                 // Check if rect is valid
                 if (!rect || rect.width === 0 || rect.height === 0) {
                     // debug("Canvas rect invalid, cannot calculate mouse position.");
                     return;
                 }
                 relativeX = e.clientX - rect.left;

                 // Scale the mouse position if the canvas CSS size differs from its internal resolution
                 if (canvas.width !== rect.width) {
                     relativeX = relativeX * (canvas.width / rect.width);
                 }

                 // Check if relativeX is a valid number before proceeding
                 if (isNaN(relativeX)) {
                     // debug("Calculated relativeX is NaN.");
                     return;
                 }

                 // Move paddle if mouse is within canvas horizontal bounds
                 if (relativeX >= 0 && relativeX <= canvas.width) {
                     let targetX = relativeX - PADDLE_WIDTH / 2;
                     // Clamp paddle position within canvas bounds
                     paddleX = Math.max(0, Math.min(canvas.width - PADDLE_WIDTH, targetX));
                     // Optional: Debug log for mouse movement causing paddle update
                     // debug(`Mouse moved: clientX=${e.clientX}, rect.left=${rect.left.toFixed(1)}, relativeX=${relativeX.toFixed(1)}, paddleX=${paddleX.toFixed(1)}`);
                 }
             } catch (error) {
                 debug("Error in mouseMoveHandler: " + error.message);
                 console.error("Error in mouseMoveHandler:", error);
             }
        }

         // --- Mobile Touch Controls ---

        function setupMobileControls() {
            const leftBtn = document.getElementById('left-btn');
            const rightBtn = document.getElementById('right-btn');
            const mobileControls = document.getElementById('mobile-controls');

            // Basic check for touch capability
            function isTouchDevice() {
                return ('ontouchstart' in window) || (navigator.maxTouchPoints > 0);
            }

            if (isTouchDevice()) {
                debug("Touch device detected, setting up mobile controls.");
                if (mobileControls) {
                    mobileControls.style.display = 'flex'; // Show controls
                } else {
                     debug("Warning: mobile-controls element not found.");
                 }

                let moveInterval = null; // Interval timer for continuous movement
                 const moveSpeed = 10; // Pixels per interval

                 function startMoving(direction) {
                     if (moveInterval) clearInterval(moveInterval); // Clear existing interval

                     moveInterval = setInterval(() => {
                         if (!gameStarted || gamePaused) {
                             clearInterval(moveInterval);
                             moveInterval = null;
                             return;
                         }
                         if (direction === 'left') {
                             paddleX -= moveSpeed;
                             if (paddleX < 0) paddleX = 0;
                             leftPressed = true; // Set flag for compatibility if needed elsewhere
                             rightPressed = false;
                         } else if (direction === 'right') {
                             paddleX += moveSpeed;
                             if (paddleX + PADDLE_WIDTH > canvas.width) paddleX = canvas.width - PADDLE_WIDTH;
                             rightPressed = true; // Set flag
                             leftPressed = false;
                         }
                     }, 20); // Move every 20ms
                 }

                 function stopMoving() {
                     if (moveInterval) clearInterval(moveInterval);
                     moveInterval = null;
                     leftPressed = false; // Reset flags
                     rightPressed = false;
                     // debug("Touch movement stopped.");
                 }


                if (leftBtn) {
                     leftBtn.addEventListener('touchstart', (e) => {
                         debug("Touch left start");
                         startMoving('left');
                         e.preventDefault();
                     }, { passive: false }); // Need passive: false for preventDefault
                     leftBtn.addEventListener('touchend', stopMoving);
                     leftBtn.addEventListener('touchcancel', stopMoving); // Handle cancellation
                } else {
                     debug("Warning: left-btn element not found.");
                 }

                if (rightBtn) {
                    rightBtn.addEventListener('touchstart', (e) => {
                         debug("Touch right start");
                         startMoving('right');
                         e.preventDefault();
                     }, { passive: false });
                    rightBtn.addEventListener('touchend', stopMoving);
                    rightBtn.addEventListener('touchcancel', stopMoving);
                 } else {
                     debug("Warning: right-btn element not found.");
                 }

             } else {
                 debug("No touch capability detected.");
                 if (mobileControls) mobileControls.style.display = 'none'; // Ensure controls are hidden
             }
        }

         // --- Game State and Audio/Visual Toggles ---

        function togglePause() {
            // Only allow pause/unpause if game is running and not on an end screen
            if (!gameStarted || gameOverScreen.style.display === 'flex' || levelCompleteScreen.style.display === 'flex') return;

            gamePaused = !gamePaused;
            pauseIndicator.style.display = gamePaused ? "block" : "none";

            if (!gamePaused) {
                // Unpausing
                lastFrameTime = performance.now(); // Reset last frame time to avoid large deltaTime jump
                requestAnimationFrame(draw); // Resume game loop
                resumeMusic();
                debug("Game unpaused");
            } else {
                // Pausing
                pauseMusic();
                 // Draw the paused text once immediately
                 if (ctx) {
                     ctx.fillStyle = "rgba(0, 0, 0, 0.5)";
                     ctx.fillRect(0, 0, canvas.width, canvas.height);
                     ctx.font = "40px Arial";
                     ctx.fillStyle = "white";
                     ctx.textAlign = "center";
                     ctx.fillText("PAUSED", canvas.width / 2, canvas.height / 2);
                 }
                debug("Game paused");
            }
        }

        function toggleSound() {
            soundEnabled = !soundEnabled;
            const soundToggle = document.getElementById('toggle-sound');
            if (soundToggle) {
                soundToggle.textContent = `Sound: ${soundEnabled ? 'ON' : 'OFF'}`;
            }
            debug(`Sound ${soundEnabled ? 'enabled' : 'disabled'}`);
        }

        function toggleMusic() {
            musicEnabled = !musicEnabled;
            const musicToggle = document.getElementById('toggle-music');
            if (musicToggle) {
                musicToggle.textContent = `Music: ${musicEnabled ? 'ON' : 'OFF'}`;
            }
            if (musicEnabled && gameStarted && !gamePaused) { // Only play if game is active
                playMusic();
            } else {
                stopMusic(); // Stop music if toggled off or game not active
            }
            debug(`Music ${musicEnabled ? 'enabled' : 'disabled'}`);
        }

        function toggleFullscreen() {
             try {
                 if (!document.fullscreenElement) {
                     document.documentElement.requestFullscreen()
                         .then(() => debug("Entered fullscreen"))
                         .catch(err => debug(`Error entering fullscreen: ${err.message}`));
                 } else {
                     if (document.exitFullscreen) {
                         document.exitFullscreen()
                             .then(() => debug("Exited fullscreen"))
                             .catch(err => debug(`Error exiting fullscreen: ${err.message}`));
                     }
                 }
             } catch (e) {
                 debug("Fullscreen API error: " + e.message);
             }
        }

         // --- Audio Generation ---

        function playMusic() {
            // Play only if enabled, game started, and not paused
             if (!musicEnabled || !gameStarted || gamePaused) {
                 // Ensure music stops if conditions aren't met
                 stopMusic();
                 return;
             }

            try {
                if (!backgroundMusic || backgroundMusic.context.state === 'closed') {
                    // Create new context if needed or if previous one closed
                     const AudioContext = window.AudioContext || window.webkitAudioContext;
                    if (!AudioContext) {
                        debug("Web Audio API not supported.");
                        musicEnabled = false; // Disable music if not supported
                        return;
                    }
                    const audioCtx = new AudioContext();
                     backgroundMusic = {
                        context: audioCtx,
                        oscillators: [], // Store multiple oscillators
                        gain: audioCtx.createGain(),
                        playing: false
                    };
                     backgroundMusic.gain.connect(audioCtx.destination);
                     debug("Audio context created.");
                }

                 // Start playback if not already playing
                if (!backgroundMusic.playing) {
                     debug("Playing background music for Level " + level);
                     // Stop any existing oscillators before creating new ones
                     backgroundMusic.oscillators.forEach(osc => { try { osc.stop(); } catch (e) {} });
                     backgroundMusic.oscillators = [];

                     // Create a simple ambient background using multiple oscillators
                     const baseFreq1 = 40 + level * 3; // Frequency increases slightly with level
                     const baseFreq2 = 60 + level * 5;
                     const freqs = [baseFreq1, baseFreq1 * 1.5, baseFreq2, baseFreq2 * 1.5]; // Create a simple chord/drone
                     const gainValue = 0.03; // Keep it subtle

                     backgroundMusic.gain.gain.setValueAtTime(gainValue, backgroundMusic.context.currentTime);

                     freqs.forEach(freq => {
                         const osc = backgroundMusic.context.createOscillator();
                         osc.type = 'sine'; // Use sine for smoother sound
                         osc.frequency.setValueAtTime(freq, backgroundMusic.context.currentTime);
                         osc.connect(backgroundMusic.gain);
                         osc.start();
                         backgroundMusic.oscillators.push(osc);
                     });
                     backgroundMusic.playing = true;
                 }

            } catch (e) {
                debug("Error playing music: " + e.message);
                console.error("Music Error:", e);
                 musicEnabled = false; // Disable music on error
                 if (backgroundMusic?.context.state !== 'closed') {
                     backgroundMusic?.context.close().catch(()=>{}); // Attempt to close context on error
                 }
                 backgroundMusic = null;
            }
        }

        function stopMusic() {
            if (backgroundMusic && backgroundMusic.playing) {
                try {
                    debug("Stopping music.");
                    backgroundMusic.oscillators.forEach(osc => { try { osc.stop(); } catch (e) {} }); // Stop all oscillators
                    backgroundMusic.oscillators = [];
                     // Optional: Fade out gain instead of cutting abruptly
                     // backgroundMusic.gain.gain.exponentialRampToValueAtTime(0.0001, backgroundMusic.context.currentTime + 0.5);
                     backgroundMusic.playing = false;
                     // We don't close the context here, just stop oscillators
                } catch (e) {
                    debug("Error stopping music: " + e.message);
                     console.error("Stop Music Error:", e);
                     // Attempt to close context if stopping fails badly
                      if (backgroundMusic?.context.state !== 'closed') {
                          backgroundMusic?.context.close().catch(()=>{});
                      }
                      backgroundMusic = null;
                }
            }
        }

        function pauseMusic() {
            if (backgroundMusic && backgroundMusic.playing && backgroundMusic.gain) {
                try {
                     // Reduce volume significantly instead of setting to 0 to avoid clicks
                     backgroundMusic.gain.gain.setTargetAtTime(0.001, backgroundMusic.context.currentTime, 0.01);
                    debug("Music paused (volume lowered).");
                } catch (e) {
                    debug("Error pausing music: " + e.message);
                }
            }
        }

        function resumeMusic() {
             // Resume only if enabled and game is active
            if (musicEnabled && gameStarted && !gamePaused && backgroundMusic && backgroundMusic.gain) {
                try {
                     // Restore volume
                     backgroundMusic.gain.gain.setTargetAtTime(0.03, backgroundMusic.context.currentTime, 0.01); // Target gain value from playMusic
                    debug("Music resumed (volume restored).");
                     // If oscillators were stopped completely, might need to restart them
                     if (!backgroundMusic.playing) {
                         playMusic(); // Restart music if it was fully stopped
                     }
                } catch (e) {
                    debug("Error resuming music: " + e.message);
                }
            }
        }

        function playSound(type) {
            if (!soundEnabled) return;

            try {
                const AudioContext = window.AudioContext || window.webkitAudioContext;
                if (!AudioContext) return; // Sound not supported

                // Use the existing context if available and running, otherwise create temporary
                 let context;
                 let shouldCloseContext = false;
                 if (backgroundMusic && backgroundMusic.context.state === 'running') {
                     context = backgroundMusic.context;
                 } else {
                     context = new AudioContext();
                     shouldCloseContext = true; // Close temporary context after sound plays
                 }

                let settings = { frequency: 440, duration: 100, type: 'sine', volume: 0.1 };

                switch(type) {
                    case 'paddle':
                        settings = { frequency: 261.63, duration: 80, type: 'sine', volume: 0.15 }; // C4
                        break;
                    case 'brick':
                         // Vary pitch slightly based on brick row or remaining hits?
                         // For now, a simple square wave sound
                        settings = { frequency: 523.25, duration: 100, type: 'square', volume: 0.08 }; // C5
                        break;
                    case 'wall':
                        settings = { frequency: 392.00, duration: 60, type: 'sine', volume: 0.1 }; // G4
                        break;
                    case 'death':
                        settings = { frequency: 110.00, duration: 400, type: 'sawtooth', volume: 0.2 }; // A2
                        break;
                    case 'levelComplete':
                        settings = { frequency: 659.25, duration: 500, type: 'triangle', volume: 0.2 }; // E5
                         // Play a little melody? (More complex)
                        break;
                    case 'powerup':
                        settings = { frequency: 783.99, duration: 200, type: 'sine', volume: 0.18 }; // G5
                        break;
                     case 'fireball_hit': // Sound for fireball destroying brick
                         settings = { frequency: 400 + Math.random() * 200, duration: 120, type: 'sawtooth', volume: 0.1 };
                         break;
                    default:
                        return; // Unknown sound type
                }

                const oscillator = context.createOscillator();
                const gainNode = context.createGain();

                oscillator.connect(gainNode);
                gainNode.connect(context.destination);

                oscillator.type = settings.type;
                oscillator.frequency.setValueAtTime(settings.frequency, context.currentTime);
                // Fade out volume
                gainNode.gain.setValueAtTime(settings.volume, context.currentTime);
                gainNode.gain.exponentialRampToValueAtTime(0.001, context.currentTime + settings.duration / 1000);

                oscillator.start(context.currentTime);
                oscillator.stop(context.currentTime + settings.duration / 1000);

                 // Clean up temporary context
                 if (shouldCloseContext) {
                     oscillator.onended = () => {
                         context.close().catch(e => debug("Error closing temp audio context: " + e.message));
                     };
                 }

            } catch (e) {
                debug("Error playing sound '" + type + "': " + e.message);
                console.error("Play Sound Error:", e);
                soundEnabled = false; // Disable sound on error
            }
        }


         // --- Collision Detection and Effects ---

        function collisionDetection() {
             let levelCleared = true; // Assume level is cleared until an active brick is found

            for (let i = balls.length - 1; i >= 0; i--) {
                let ball = balls[i];
                let collisionOccurred = false; // Flag to prevent multiple collisions for one ball in one frame

                for (let c = 0; c < BRICK_COLUMNS && !collisionOccurred; c++) {
                    for (let r = 0; r < BRICK_ROWS && !collisionOccurred; r++) {
                         const b = bricks[c]?.[r];
                         if (b && b.status > 0) {
                             levelCleared = false; // Found an active brick

                            // Use calculated brick position
                             const brickX = b.x;
                             const brickY = b.y;

                            // Simple AABB collision check first for performance
                             if (ball.x + ball.radius > brickX &&
                                 ball.x - ball.radius < brickX + BRICK_WIDTH &&
                                 ball.y + ball.radius > brickY &&
                                 ball.y - ball.radius < brickY + BRICK_HEIGHT)
                             {
                                // More precise check needed to determine bounce direction
                                // Find closest point on brick rectangle to ball center
                                let closestX = Math.max(brickX, Math.min(ball.x, brickX + BRICK_WIDTH));
                                let closestY = Math.max(brickY, Math.min(ball.y, brickY + BRICK_HEIGHT));
                                // Calculate distance between ball center and closest point
                                let dx = ball.x - closestX;
                                let dy = ball.y - closestY;
                                let distanceSquared = (dx * dx) + (dy * dy);

                                // Collision if distance is less than ball radius squared
                                if (distanceSquared < (ball.radius * ball.radius)) {

                                     // --- Collision Response ---

                                     // Fireball effect check FIRST
                                     if (ball.fireball) {
                                         applyFireballEffect(ball.x, ball.y, b); // Pass the hit brick too
                                         collisionOccurred = true; // Handled by fireball
                                         playSound('fireball_hit');
                                         continue; // Move to next brick/ball
                                     }

                                     // Normal collision
                                     // Determine primary collision axis (crude method)
                                     // Calculate overlap
                                     let overlapX = ball.radius - Math.abs(dx);
                                     let overlapY = ball.radius - Math.abs(dy);

                                     // Reverse appropriate velocity component
                                     if (overlapX > overlapY) { // Likely horizontal collision
                                         ball.speedY = -ball.speedY;
                                         // Nudge ball out vertically
                                         ball.y += (dy > 0 ? 1 : -1) * overlapY;
                                     } else { // Likely vertical collision
                                         ball.speedX = -ball.speedX;
                                         // Nudge ball out horizontally
                                         ball.x += (dx > 0 ? 1 : -1) * overlapX;
                                     }


                                    // Process brick hit
                                    b.status--;
                                    bricksHit++;

                                    // Score calculation
                                    let pointValue = 10 * level * (b.special ? 2 : 1);
                                    // Add combo bonus
                                    if (comboTimer > 0) {
                                        combo++;
                                        if (combo > maxCombo) maxCombo = combo;
                                        pointValue *= (1 + combo * 0.1); // 10% bonus per combo level
                                    } else {
                                        combo = 1; // Start combo
                                         if (combo > maxCombo) maxCombo = combo;
                                    }
                                    score += Math.round(pointValue);
                                    comboTimer = 120; // Reset combo timer (e.g., 2 seconds at 60fps)

                                    // Update Displays
                                    if (scoreDisplay) scoreDisplay.textContent = `Score: ${score}`;
                                     if (comboDisplay) {
                                         comboDisplay.textContent = `Combo x${combo}`;
                                         comboDisplay.style.opacity = "1"; // Make combo visible
                                     }


                                    // Effects
                                    createParticles(closestX, closestY, b.color); // Particles from collision point
                                    playSound('brick');

                                    // Create power-up if brick is fully destroyed
                                    if (b.status === 0) {
                                        createPowerup(brickX + BRICK_WIDTH / 2, brickY + BRICK_HEIGHT / 2);
                                         // Extra effects for special bricks being destroyed
                                         if (b.special) {
                                             flashScreen();
                                             shakeScreen();
                                         }
                                    }

                                     // --- Ball Speed Increase ---
                                     // Slightly increase speed based on progress (but not during slowBall powerup)
                                     const speedIncreaseFactor = 1.001; // Very small increase per hit
                                     const maxSpeed = 6 + level; // Max speed increases with level
                                     if (!activePowerupType || activePowerupType !== 'slowBall') {
                                         let currentSpeed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                                         let targetSpeed = Math.min(maxSpeed, currentSpeed * speedIncreaseFactor);
                                         let speedRatio = targetSpeed / currentSpeed;
                                         if (currentSpeed > 0) { // Avoid division by zero
                                            ball.speedX *= speedRatio;
                                            ball.speedY *= speedRatio;
                                         }
                                     }

                                    collisionOccurred = true; // Mark collision handled for this ball this frame
                                }
                            }
                        }
                    } // End row loop
                } // End column loop

                 // After checking all bricks for this ball, check if level is complete
                 if (bricksHit >= totalBricks) {
                     levelComplete();
                     return; // Stop further processing once level is complete
                 }

            } // End loop through balls

             // If loop finishes and levelCleared is still true, something is wrong (no active bricks found but level not complete)
             if (levelCleared && gameStarted && bricksHit < totalBricks) {
                  debug(`Warning: No active bricks found, but bricksHit (${bricksHit}) < totalBricks (${totalBricks}). Forcing level complete.`);
                  // This might happen if totalBricks count was wrong or bricksHit count got desynced
                  // levelComplete(); // Uncomment carefully, might hide bugs
              }
        }

        // Fireball effect - destroy brick and possibly adjacent ones (simplified)
         function applyFireballEffect(ballX, ballY, hitBrick) {
             debug("Applying fireball effect");
             const radius = 30; // Fireball area of effect radius

             // Destroy the directly hit brick regardless of distance check
             if (hitBrick && hitBrick.status > 0) {
                 let pointValue = 5 * level; // Lower score for AoE destruction
                 score += Math.round(pointValue);
                 createParticles(hitBrick.x + BRICK_WIDTH / 2, hitBrick.y + BRICK_HEIGHT / 2, hitBrick.color);
                 let hitsToDestroy = hitBrick.status;
                 bricksHit += hitsToDestroy;
                 hitBrick.status = 0; // Instantly destroy
                 // Don't create powerup from direct fireball hit maybe? Or maybe do? Let's allow it.
                 createPowerup(hitBrick.x + BRICK_WIDTH / 2, hitBrick.y + BRICK_HEIGHT / 2);
             }

             // Check nearby bricks for AoE damage
             for (let c = 0; c < BRICK_COLUMNS; c++) {
                 for (let r = 0; r < BRICK_ROWS; r++) {
                     let b = bricks[c]?.[r];
                     // Check if brick exists, is not the directly hit one, and is still active
                     if (b && b !== hitBrick && b.status > 0) {
                         const brickCenterX = b.x + BRICK_WIDTH / 2;
                         const brickCenterY = b.y + BRICK_HEIGHT / 2;
                         const distance = Math.sqrt(Math.pow(ballX - brickCenterX, 2) + Math.pow(ballY - brickCenterY, 2));

                         if (distance < radius) { // If within AoE radius
                             debug(`Fireball destroying adjacent brick at [${c}, ${r}]`);
                             let pointValue = 5 * level;
                             score += Math.round(pointValue);
                             createParticles(brickCenterX, brickCenterY, b.color);
                             let hitsToDestroy = b.status;
                             bricksHit += hitsToDestroy;
                             b.status = 0; // Instantly destroy
                             // Create powerup for AoE destroyed bricks too
                              createPowerup(brickCenterX, brickCenterY);
                         }
                     }
                 }
             }
             // Update score display after potential multi-destruction
             if (scoreDisplay) {
                 scoreDisplay.textContent = `Score: ${score}`;
             }
             // Check for level completion immediately after fireball effect
              if (bricksHit >= totalBricks) {
                  levelComplete();
              }
         }


        // Particle system
        function createParticles(x, y, color) {
            if (!color) color = '#ffffff'; // Default color if none provided
            const numParticles = 8 + Math.floor(Math.random() * 5); // 8-12 particles
            for (let i = 0; i < numParticles; i++) {
                particles.push({
                    x: x,
                    y: y,
                    vx: (Math.random() - 0.5) * 6, // Reduced velocity range
                    vy: (Math.random() - 0.5) * 6,
                    radius: Math.random() * 2.5 + 1, // Slightly smaller particles
                    color: color,
                    alpha: 1,
                    life: Math.random() * 30 + 20 // Shorter lifespan (30-50 frames)
                });
            }
        }

        function updateParticles(deltaTime) {
             const decayRate = (deltaTime / 16.67); // Adjust decay based on frame time (relative to 60fps)
            for (let i = particles.length - 1; i >= 0; i--) {
                let p = particles[i];
                p.x += p.vx * decayRate;
                p.y += p.vy * decayRate;
                p.vx *= 0.96; // Air resistance/friction
                p.vy *= 0.96; // Air resistance/friction
                 p.vy += 0.05 * decayRate; // Subtle gravity
                p.life -= decayRate; // Decrease life based on delta time
                p.alpha = Math.max(0, p.life / 50); // Fade out alpha based on remaining life

                if (p.life <= 0) {
                    particles.splice(i, 1); // Remove dead particles
                }
            }
        }


        function drawParticles() {
            ctx.globalCompositeOperation = 'lighter'; // Additive blending for brighter particles
            for (let i = 0; i < particles.length; i++) {
                let p = particles[i];
                ctx.globalAlpha = p.alpha;
                ctx.beginPath();
                ctx.arc(p.x, p.y, p.radius, 0, Math.PI * 2);
                ctx.fillStyle = p.color;
                ctx.fill();
                 // Optional: Add subtle glow using shadow (can impact performance)
                 // ctx.shadowColor = p.color;
                 // ctx.shadowBlur = 5;
                 // ctx.fill();
                 // ctx.shadowColor = 'transparent';
                 // ctx.shadowBlur = 0;
            }
            ctx.globalAlpha = 1; // Reset global alpha
             ctx.globalCompositeOperation = 'source-over'; // Reset composite operation
        }

        // Screen effects
        function flashScreen() {
            if (screenFlash) {
                screenFlash.style.opacity = 0.7;
                setTimeout(() => {
                    screenFlash.style.opacity = 0;
                }, 80); // Shorter flash duration
            }
        }

        function shakeScreen() {
            const gameContainer = document.getElementById('game-container');
            if (gameContainer && !screenShaking) {
                screenShaking = true;
                gameContainer.classList.add('shaking');
                 // Use animationend event if possible for more robust timing
                 const handleShakeEnd = () => {
                     gameContainer.classList.remove('shaking');
                     screenShaking = false;
                     gameContainer.removeEventListener('animationend', handleShakeEnd);
                 };
                 gameContainer.addEventListener('animationend', handleShakeEnd);
                // Fallback timeout if animationend doesn't fire (e.g., short animations)
                 setTimeout(() => {
                     if (screenShaking) { // Only remove if still shaking (in case event fired)
                         handleShakeEnd();
                     }
                 }, 500); // Corresponds to CSS animation duration
            }
        }

         // --- Power-ups ---

        const POWERUP_TYPES = [
            { type: 'extraLife', color: '#FF5555', text: '❤️', chance: 0.15 },
            { type: 'widenPaddle', color: '#55FF55', text: '↔️', chance: 0.25 },
            { type: 'slowBall', color: '#5555FF', text: '🐢', chance: 0.20 },
            { type: 'multiball', color: '#FFAA00', text: '🔄', chance: 0.20 },
            { type: 'fireball', color: '#FF0000', text: '🔥', chance: 0.10 },
             { type: 'points', color: '#FFFF00', text: '💰', chance: 0.10 } // Example: Point bonus
        ];

        function createPowerup(brickCenterX, brickCenterY) {
             // Adjust overall chance based on level (e.g., slightly higher chance in later levels)
             let basePowerupChance = 0.25; // 25% base chance
             let levelFactor = (level - 1) * 0.02; // +2% chance per level after level 1
             let overallChance = Math.min(0.5, basePowerupChance + levelFactor); // Cap at 50%

            if (Math.random() < overallChance) {
                // Calculate total weight/chance pool
                let totalChance = POWERUP_TYPES.reduce((sum, pt) => sum + pt.chance, 0);
                let randomValue = Math.random() * totalChance;
                let cumulativeChance = 0;
                let selectedType = POWERUP_TYPES[0]; // Default fallback

                for (const powerupType of POWERUP_TYPES) {
                    cumulativeChance += powerupType.chance;
                    if (randomValue <= cumulativeChance) {
                        selectedType = powerupType;
                        break;
                    }
                }

                powerups.push({
                    x: brickCenterX - 15, // Center the powerup visually
                    y: brickCenterY - 15,
                    type: selectedType.type,
                    color: selectedType.color,
                    text: selectedType.text,
                    width: 30,
                    height: 30,
                    speed: 1.5 + level * 0.1 // Speed increases slightly with level
                });
                debug(`Created ${selectedType.type} powerup`);
            }
        }

        function updatePowerups(deltaTime) {
            const fallSpeedFactor = (deltaTime / 16.67); // Adjust speed based on frame time

            for (let i = powerups.length - 1; i >= 0; i--) {
                let p = powerups[i];
                p.y += p.speed * fallSpeedFactor;

                // Check if power-up is caught by paddle (AABB collision)
                if (p.y + p.height > canvas.height - PADDLE_HEIGHT && // Below paddle top
                    p.y < canvas.height && // Above canvas bottom
                    p.x + p.width > paddleX && // Right of paddle left edge
                    p.x < paddleX + PADDLE_WIDTH) // Left of paddle right edge
                {
                    activatePowerup(p.type);
                    powerups.splice(i, 1); // Remove caught power-up
                    playSound('powerup');
                }
                // Remove if falls below screen
                else if (p.y > canvas.height + p.height) { // Allow it to fall fully off screen
                    powerups.splice(i, 1);
                }
            }

            // Handle active timed power-up timer
            if (powerupActive) {
                powerupTimer -= fallSpeedFactor; // Decrease timer based on delta time
                if (powerupTimer <= 0) {
                    deactivatePowerup();
                }
            }
        }


         function activatePowerup(type) {
             // Deactivate existing timed power-up if activating a new conflicting one
             if (powerupActive && type !== 'extraLife' && type !== 'multiball' && type !== 'points') {
                 deactivatePowerup();
             }

             // Set timer only for timed power-ups
             if (type === 'widenPaddle' || type === 'slowBall' || type === 'fireball') {
                  powerupActive = true;
                  activePowerupType = type;
                  powerupTimer = 600; // Approx 10 seconds at 60fps
                  debug(`Activated ${type} powerup for ${powerupTimer / 60} seconds`);
             } else {
                 // Immediate effect power-ups don't set the timer/active state
                  debug(`Activated immediate powerup: ${type}`);
             }

             flashScreen(); // Visual feedback for any power-up

             switch (type) {
                 case 'extraLife':
                     lives++;
                     if (livesDisplay) livesDisplay.textContent = `Lives: ${lives}`;
                     break;
                 case 'widenPaddle':
                     PADDLE_WIDTH = paddleWidthWide;
                     // Adjust paddle position if widening pushes it off-screen
                      if (paddleX + PADDLE_WIDTH > canvas.width) {
                          paddleX = canvas.width - PADDLE_WIDTH;
                      }
                     break;
                 case 'slowBall':
                     balls.forEach(ball => {
                         // Reduce speed while preserving direction
                          const currentSpeed = Math.sqrt(ball.speedX**2 + ball.speedY**2);
                          if (currentSpeed > 0) { // Avoid division by zero
                             const ratio = ballSpeedSlow / currentSpeed;
                             ball.speedX *= ratio;
                             ball.speedY *= ratio;
                          }
                     });
                     break;
                 case 'multiball':
                     // Add up to 2 more balls if below limit
                     const maxBalls = 3;
                     const ballsToAdd = Math.min(2, maxBalls - balls.length); // Add up to 2, but don't exceed max
                     if (ballsToAdd > 0 && balls.length > 0) {
                         const sourceBall = balls[0]; // Use first ball as source
                         for (let i = 0; i < ballsToAdd; i++) {
                             // Launch new balls at slight angle variations
                              const angleOffset = (Math.PI / 6) * (i + 1); // 30, 60 degrees offset
                              const sourceSpeed = Math.sqrt(sourceBall.speedX**2 + sourceBall.speedY**2);
                              const newSpeedX = sourceSpeed * Math.cos(angleOffset);
                              const newSpeedY = -sourceSpeed * Math.sin(angleOffset); // Start moving upwards

                             balls.push({
                                 x: sourceBall.x,
                                 y: sourceBall.y,
                                 speedX: newSpeedX * (i % 2 === 0 ? 1 : -1), // Alternate horizontal direction
                                 speedY: newSpeedY,
                                 radius: BALL_RADIUS,
                                 fireball: sourceBall.fireball // New balls inherit fireball status
                             });
                         }
                         multiballActive = true; // Set flag (might be useful for specific logic)
                     }
                     break;
                 case 'fireball':
                     balls.forEach(ball => { ball.fireball = true; });
                     break;
                 case 'points': // Example: Immediate point bonus
                     const pointsBonus = 100 * level;
                      score += pointsBonus;
                      if (scoreDisplay) scoreDisplay.textContent = `Score: ${score}`;
                      // Display floating text effect? (More complex)
                      debug(`Awarded ${pointsBonus} bonus points`);
                      break;
             }
         }


         function deactivatePowerup() {
             if (!powerupActive || !activePowerupType) return;

             debug(`Deactivated ${activePowerupType} powerup`);

             switch (activePowerupType) {
                 case 'widenPaddle':
                     PADDLE_WIDTH = paddleWidthNormal;
                     // No need to readjust position here, happens naturally or on next move
                     break;
                 case 'slowBall':
                      // Restore normal base speed, preserving direction
                      balls.forEach(ball => {
                          const currentSpeed = Math.sqrt(ball.speedX**2 + ball.speedY**2);
                          if (currentSpeed > 0) { // Avoid division by zero
                             // Calculate base speed considering level progression
                              let baseSpeed = 4 + (level - 1) * 0.5;
                              let speedMultiplier = 1 + (bricksHit / totalBricks) * 0.3; // Factor from collision detection
                              let targetNormalSpeed = Math.min(6 + level, baseSpeed * speedMultiplier);

                             const ratio = targetNormalSpeed / currentSpeed;
                             ball.speedX *= ratio;
                             ball.speedY *= ratio;
                          }
                      });
                     break;
                 case 'fireball':
                     balls.forEach(ball => { ball.fireball = false; });
                     break;
             }

             powerupActive = false;
             activePowerupType = null;
             powerupTimer = 0;
         }


         function drawPowerups() {
             for (let i = 0; i < powerups.length; i++) {
                 let p = powerups[i];
                 // Draw power-up background
                 ctx.beginPath();
                 if (ctx.roundRect) {
                     ctx.roundRect(p.x, p.y, p.width, p.height, 5);
                 } else {
                     ctx.rect(p.x, p.y, p.width, p.height);
                 }
                 ctx.fillStyle = p.color;
                 // Add slight transparency
                 ctx.globalAlpha = 0.9;
                 ctx.fill();
                  // Add subtle border
                  ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
                  ctx.lineWidth = 1;
                  ctx.stroke();
                  ctx.globalAlpha = 1; // Reset alpha
                 ctx.closePath();


                 // Draw power-up text/icon
                 ctx.font = '18px Arial'; // Use a font that supports emojis well if needed
                 ctx.textAlign = 'center';
                 ctx.textBaseline = 'middle';
                 ctx.fillStyle = 'white';
                 // Add text shadow for contrast
                 ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                 ctx.shadowBlur = 2;
                 ctx.shadowOffsetX = 1;
                 ctx.shadowOffsetY = 1;
                 ctx.fillText(p.text, p.x + p.width / 2, p.y + p.height / 2 + 1); // Adjust Y for better vertical centering

                 // Reset shadow
                 ctx.shadowColor = 'transparent';
                 ctx.shadowBlur = 0;
                 ctx.shadowOffsetX = 0;
                 ctx.shadowOffsetY = 0;

                 // Draw a glow effect (optional, can impact performance)
                 // ctx.beginPath();
                 // ... glow drawing ...
                 // ctx.closePath();
             }

             // Draw active timed power-up indicator near the paddle
             if (powerupActive && activePowerupType) {
                 let indicator = '';
                 let color = 'white';
                 const powerupInfo = POWERUP_TYPES.find(pt => pt.type === activePowerupType);
                 if (powerupInfo) {
                      indicator = powerupInfo.text;
                      color = powerupInfo.color;
                 }


                 if (indicator) {
                     const indicatorY = canvas.height - PADDLE_HEIGHT - 25; // Position above paddle
                     // Draw indicator text
                     ctx.font = '20px Arial';
                     ctx.textAlign = 'center';
                     ctx.fillStyle = color;
                      // Add shadow
                     ctx.shadowColor = 'rgba(0, 0, 0, 0.7)';
                     ctx.shadowBlur = 3;
                     ctx.fillText(indicator, paddleX + PADDLE_WIDTH / 2, indicatorY);
                     // Reset shadow
                     ctx.shadowColor = 'transparent';
                     ctx.shadowBlur = 0;


                     // Draw timer bar below the indicator
                     const barWidth = 50;
                     const barHeight = 6;
                     const barX = paddleX + PADDLE_WIDTH / 2 - barWidth / 2;
                     const barY = indicatorY + 8; // Below the indicator text

                     // Background of timer bar
                     ctx.fillStyle = 'rgba(0, 0, 0, 0.6)';
                     ctx.fillRect(barX, barY, barWidth, barHeight);

                     // Fill based on remaining time (timer starts at 600)
                     const remainingRatio = Math.max(0, powerupTimer / 600);
                     ctx.fillStyle = color;
                     ctx.fillRect(barX, barY, barWidth * remainingRatio, barHeight);
                      // Add a thin border to the timer bar
                      ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                      ctx.lineWidth = 1;
                      ctx.strokeRect(barX, barY, barWidth, barHeight);
                 }
             }
         }


         // --- Background Effects ---

        function drawBackground() {
            // Draw a gradient background based on theme
            let bgGradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            bgGradient.addColorStop(0, themes[currentTheme].background.start);
            bgGradient.addColorStop(1, themes[currentTheme].background.end);
            ctx.fillStyle = bgGradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw stars
             ctx.fillStyle = 'rgba(255, 255, 255, 0.7)'; // Base star color/opacity
            stars.forEach(star => {
                 ctx.save(); // Save context state
                 ctx.globalAlpha = star.brightness; // Apply individual star brightness
                 ctx.beginPath();
                ctx.arc(star.x, star.y, star.radius, 0, Math.PI * 2);
                 ctx.fill();
                 ctx.restore(); // Restore context state (including globalAlpha)
            });
        }

        function createStars() {
            stars = [];
            const numStars = 150; // More stars for denser field
            for (let i = 0; i < numStars; i++) {
                stars.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    radius: Math.random() * 1.2 + 0.3, // Range from 0.3 to 1.5
                    // Brightness will oscillate between 0.3 and 1.0
                    brightness: Math.random() * 0.7 + 0.3,
                    blinkSpeed: (Math.random() - 0.5) * 0.03 // Slower blink rate variation
                });
            }
            debug(`Created ${numStars} stars for background`);
        }

        function updateStars(deltaTime) {
            const blinkFactor = (deltaTime / 16.67); // Adjust speed based on frame time

            stars.forEach(star => {
                star.brightness += star.blinkSpeed * blinkFactor;
                // Reverse blink direction if bounds are hit
                if (star.brightness > 1.0) {
                    star.brightness = 1.0;
                    star.blinkSpeed = -Math.abs(star.blinkSpeed); // Ensure negative speed
                } else if (star.brightness < 0.3) {
                    star.brightness = 0.3;
                    star.blinkSpeed = Math.abs(star.blinkSpeed); // Ensure positive speed
                }
                 // Optional: Add subtle parallax scrolling effect
                 // star.y += 0.1 * blinkFactor; // Move stars down slowly
                 // if (star.y > canvas.height) { // Wrap around
                 //     star.y = 0;
                 //     star.x = Math.random() * canvas.width;
                 // }
            });
        }

         // --- Main Game Loop ---

        function draw(timestamp) {
            if (gamePaused) {
                 // If paused, don't update or request new frame, just wait
                 return;
             }
             if (!gameStarted) {
                  // If game hasn't started (e.g., initial load before start button), don't run loop
                  debug("Draw loop called but game not started.");
                  return;
              }


            // Calculate delta time for frame-rate independent physics/animations
             if (!lastFrameTime) {
                 lastFrameTime = timestamp; // Initialize on first frame
             }
             const deltaTime = timestamp - lastFrameTime;
             lastFrameTime = timestamp;

             // Avoid large deltaTime spikes if tab was inactive - cap delta time
              const maxDeltaTime = 50; // Max ms allowed between frames (e.g., ~20fps equivalent)
              const clampedDeltaTime = Math.min(deltaTime, maxDeltaTime);


            // Update game time (used for animations like moving bricks)
             gameTime += clampedDeltaTime;

            // --- Update ---
             updateStars(clampedDeltaTime);
             updateParticles(clampedDeltaTime);
             updatePowerups(clampedDeltaTime);
             // Update ball physics and check collisions
             updateBallsAndCollisions(clampedDeltaTime);
             // Update paddle position based on input flags
             updatePaddlePosition(clampedDeltaTime);


            // --- Draw ---
             // Clear the canvas (essential step)
            ctx.clearRect(0, 0, canvas.width, canvas.height);

             // Draw background first
            drawBackground();

            // Draw game elements
            drawBricks();
            drawPaddle(); // Draw paddle before balls
            drawPowerups(); // Draw powerups falling
            drawBall(); // Draw balls on top
            drawParticles(); // Draw particles last for visual flair


            // --- FPS Calculation and Display ---
            frameCount++;
            if (timestamp - lastFpsUpdate > 1000) { // Update FPS display every second
                fps = frameCount; // FPS = frames in the last second
                lastFpsUpdate = timestamp;
                frameCount = 0;
                if (fpsDisplay) {
                    fpsDisplay.textContent = `FPS: ${fps}`;
                }
            }

             // --- Combo Timer Update ---
             if (comboTimer > 0) {
                 comboTimer -= (clampedDeltaTime / 16.67); // Decrease based on 60fps frame time
                 if (comboTimer <= 0) {
                     combo = 0; // Reset combo
                     if (comboDisplay) comboDisplay.style.opacity = "0"; // Hide combo display
                 }
             }

            // Continue the animation loop
             if (gameStarted) { // Double check game hasn't ended during this frame
                requestAnimationFrame(draw);
             }
        }


         // --- Helper function to update ball physics and handle collisions ---
         function updateBallsAndCollisions(deltaTime) {
             const speedFactor = deltaTime / 16.67; // Adjust speed based on frame time

             for (let i = balls.length - 1; i >= 0; i--) { // Loop backwards for safe removal
                 let ball = balls[i];

                 // --- Ball-Wall Collisions ---
                 let nextX = ball.x + ball.speedX * speedFactor;
                 let nextY = ball.y + ball.speedY * speedFactor;

                 // Right wall
                 if (nextX + ball.radius > canvas.width) {
                     ball.speedX = -Math.abs(ball.speedX); // Ensure moving left
                     ball.x = canvas.width - ball.radius; // Correct position
                     playSound('wall');
                     createParticles(ball.x, ball.y, themes[currentTheme].particles.wall);
                 }
                 // Left wall
                 else if (nextX - ball.radius < 0) {
                     ball.speedX = Math.abs(ball.speedX); // Ensure moving right
                     ball.x = ball.radius; // Correct position
                     playSound('wall');
                      createParticles(ball.x, ball.y, themes[currentTheme].particles.wall);
                 }

                 // Top wall
                 if (nextY - ball.radius < 0) {
                     ball.speedY = Math.abs(ball.speedY); // Ensure moving down
                     ball.y = ball.radius; // Correct position
                     playSound('wall');
                      createParticles(ball.x, ball.y, themes[currentTheme].particles.wall);
                 }
                 // Bottom edge (loss condition / paddle collision)
                 else if (nextY + ball.radius > canvas.height) {
                     // Check for paddle collision ONLY if ball is near paddle height
                     if (ball.y < canvas.height - PADDLE_HEIGHT && // Ball was above paddle top
                         nextX > paddleX - ball.radius && // Within horizontal range (allowing for radius)
                         nextX < paddleX + PADDLE_WIDTH + ball.radius)
                      {
                          // --- Paddle Collision ---
                          // Calculate bounce angle based on where ball hits the paddle
                          let hitPosRatio = (ball.x - (paddleX + PADDLE_WIDTH / 2)) / (PADDLE_WIDTH / 2);
                          hitPosRatio = Math.max(-1, Math.min(1, hitPosRatio)); // Clamp between -1 and 1

                          let bounceAngle = hitPosRatio * (Math.PI / 2.5); // Max angle ~72 degrees

                          // Maintain current speed magnitude
                          let speed = Math.sqrt(ball.speedX * ball.speedX + ball.speedY * ball.speedY);
                          // Add slight speed boost on paddle hit, capped
                           speed = Math.min(speed * 1.02, 8 + level); // Cap speed increase

                          ball.speedX = speed * Math.sin(bounceAngle);
                          ball.speedY = -speed * Math.cos(bounceAngle); // Ensure moving up

                          // Correct position to be just above the paddle
                           ball.y = canvas.height - PADDLE_HEIGHT - ball.radius;

                          paddleHits++;
                          playSound('paddle');
                          createParticles(ball.x, ball.y, themes[currentTheme].particles.paddle);

                           // Reset combo if ball hits paddle
                           // combo = 0;
                           // if (comboDisplay) comboDisplay.style.opacity = "0";
                           // comboTimer = 0;
                      } else {
                          // --- Ball Missed Paddle ---
                          if (balls.length > 1) {
                              // Remove this ball if it's not the last one
                              debug(`Multiball lost ball ${i+1}`);
                              balls.splice(i, 1);
                              continue; // Skip position update for removed ball
                          } else {
                              // Last ball - lose a life
                              lives--;
                              if (livesDisplay) livesDisplay.textContent = `Lives: ${lives}`;
                              playSound('death');
                              flashScreen();
                              shakeScreen();

                              if (lives <= 0) {
                                  gameOver();
                                  return; // Stop processing other balls/updates
                              } else {
                                  // Reset ball and paddle for the new life
                                   resetBallAndPaddle();
                                   // Deactivate any active powerups on life loss
                                   if (powerupActive) deactivatePowerup();
                                   // Reset fireball status
                                   balls[0].fireball = false;
                              }
                          }
                     }
                 }

                 // --- Ball-Brick Collision --- (Call the dedicated function)
                 collisionDetection(); // Checks all balls against all bricks

                  // Update ball position based on potentially modified velocity
                  ball.x += ball.speedX * speedFactor;
                  ball.y += ball.speedY * speedFactor;

                 // Fireball particle trail
                 if (ball.fireball) {
                      // Create fewer trail particles for performance
                      if (Math.random() < 0.5) {
                         createParticles(ball.x - ball.speedX * speedFactor / 2, ball.y - ball.speedY * speedFactor / 2, '#ff6600'); // Trail behind
                      }
                 }
            } // End loop through balls
         }

         // --- Helper function to update paddle position ---
         function updatePaddlePosition(deltaTime) {
             const moveSpeed = 8 * (deltaTime / 16.67); // Keyboard move speed adjusted for frame time

             if (rightPressed) {
                 paddleX += moveSpeed;
             } else if (leftPressed) {
                 paddleX -= moveSpeed;
             }

             // Clamp paddle position to canvas bounds after keyboard movement
             paddleX = Math.max(0, Math.min(canvas.width - PADDLE_WIDTH, paddleX));
         }

         // --- Helper function to reset ball and paddle ---
         function resetBallAndPaddle() {
             debug("Resetting ball and paddle position.");
             paddleX = (canvas.width - PADDLE_WIDTH) / 2;
              // Reset the single remaining ball or the first ball
             if (balls.length > 0) {
                 const ball = balls[0];
                 ball.x = canvas.width / 2;
                 ball.y = canvas.height - PADDLE_HEIGHT - BALL_RADIUS - 10; // Position above paddle
                 // Reset speed with slight randomness
                 let baseSpeed = 4 + (level - 1) * 0.5;
                 ball.speedX = baseSpeed * (Math.random() > 0.5 ? 1 : -1);
                 ball.speedY = -baseSpeed; // Ensure moving upwards
                 ball.fireball = false; // Ensure fireball is off on reset
             }
              // Ensure only one ball exists after reset
              if (balls.length > 1) {
                  balls = [balls[0]];
              }
              multiballActive = false;
         }

        // --- Game State Changes (Start, Restart, Next Level, Game Over) ---

        function startGame() {
            debug("Attempting to start game...");
            // Ensure elements are ready
            if (!canvas || !ctx) {
                if (!initializeElements()) { // Try initializing again
                    alert("Could not initialize critical game elements. Please reload the page.");
                    return;
                }
            }
            gameStarted = true;
             gamePaused = false; // Ensure not paused on start
            if (startScreen) startScreen.style.display = "none";
             if (gameOverScreen) gameOverScreen.style.display = "none";
             if (levelCompleteScreen) levelCompleteScreen.style.display = "none";
             if (highScores) highScores.style.display = "none"; // Hide high scores if visible

            startTime = performance.now();
            lastFrameTime = performance.now(); // Reset frame timer
            gameTime = 0; // Reset total game time

            // Reset game variables
            score = 0;
            lives = 3;
            level = 1;
            bricksHit = 0;
            paddleHits = 0;
            combo = 0;
            maxCombo = 0;
            comboTimer = 0;
            particles = [];
            powerups = [];
            if (scoreDisplay) scoreDisplay.textContent = `Score: ${score}`;
            if (livesDisplay) livesDisplay.textContent = `Lives: ${lives}`;
            if (levelDisplay) levelDisplay.textContent = `Level ${level}`;
            if (comboDisplay) comboDisplay.style.opacity = "0";

             // Reset ball and paddle position/speed for level 1
             resetBallAndPaddle(); // Use helper function

            createBricks(); // Create bricks for level 1
            playMusic(); // Start music

            // Ensure debug panel state is correct
             if (DEBUG_MODE && debugPanel) debugPanel.style.display = 'block';
             else if (debugPanel) debugPanel.style.display = 'none';

            debug("Game started successfully! Level 1");
            requestAnimationFrame(draw); // Start the game loop
        }


        function restartGame() {
            debug("Restarting game...");
            stopMusic(); // Stop current music
             if (powerupActive) deactivatePowerup(); // Clean up powerups

             // Reset all state by calling startGame
             startGame();
        }

        function nextLevel() {
             level++;
            debug(`Starting level ${level}...`);
             gameStarted = true; // Ensure game stays started
             gamePaused = false;
            if (levelCompleteScreen) levelCompleteScreen.style.display = "none";

            // Reset level-specific stats, keep score and lives
            bricksHit = 0;
            paddleHits = 0; // Reset paddle hits per level? Optional.
            combo = 0;
            comboTimer = 0;
            if (levelDisplay) levelDisplay.textContent = `Level ${level}`;
            if (comboDisplay) comboDisplay.style.opacity = "0";

            // Reset ball and paddle
             resetBallAndPaddle();

            // Clear particles & powerups from previous level
            particles = [];
            powerups = [];
            if (powerupActive) deactivatePowerup(); // Deactivate powerup from previous level

            createBricks(); // Create bricks for the new level

            // Restart music (might change based on level later)
             playMusic();

            requestAnimationFrame(draw); // Continue game loop
        }

        function gameOver() {
            debug("Game over!");
            gameStarted = false; // Stop game loop requests
            stopMusic();
             if (powerupActive) deactivatePowerup(); // Clean up powerups

            if (gameOverScreen) {
                gameOverScreen.style.display = "flex";
                // Format total game time
                let totalSeconds = Math.floor(gameTime / 1000);
                let minutes = Math.floor(totalSeconds / 60);
                let seconds = totalSeconds % 60;
                let timeString = `${minutes}m ${seconds.toString().padStart(2, '0')}s`;

                if (finalScoreDisplay) finalScoreDisplay.textContent = `Final Score: ${score}`;
                if (gameStatsDisplay) {
                    gameStatsDisplay.innerHTML = `
                        Level Reached: ${level}<br>
                        Total Bricks Destroyed: ${bricksHit}<br>
                        Total Paddle Hits: ${paddleHits}<br>
                        Max Combo: x${maxCombo}<br>
                        Time Played: ${timeString}
                    `;
                }

                // High score handling
                const newHighScoreText = document.getElementById('new-high-score');
                const nameInput = document.getElementById('name-input');
                const saveScoreBtn = document.getElementById('save-score-button');

                 // Reset input fields from previous game over if any
                 if (nameInput) nameInput.value = '';
                 if (newHighScoreText) newHighScoreText.style.display = 'none';
                 if (nameInput) nameInput.style.display = 'none';
                 if (saveScoreBtn) saveScoreBtn.style.display = 'none';


                if (isHighScore(score)) {
                    debug("New high score achieved!");
                    if (newHighScoreText) newHighScoreText.style.display = 'block';
                    if (nameInput) nameInput.style.display = 'block';
                    if (saveScoreBtn) {
                         saveScoreBtn.style.display = 'block';
                         // Add temporary event listener for this instance
                         const saveHandler = () => {
                             const name = nameInput.value.trim().substring(0, 15) || 'Player'; // Limit name length
                             addHighScore(name, score, level);
                             // Hide input elements after saving
                             if (newHighScoreText) newHighScoreText.style.display = 'none';
                             if (nameInput) nameInput.style.display = 'none';
                             if (saveScoreBtn) saveScoreBtn.style.display = 'none';
                             // Automatically show updated high scores screen
                              displayHighScores();
                              const hsScreen = document.getElementById('high-scores');
                              if (hsScreen) hsScreen.style.display = 'flex';
                              if (gameOverScreen) gameOverScreen.style.display = 'none'; // Hide game over screen
                              saveScoreBtn.removeEventListener('click', saveHandler); // Clean up listener
                         };
                         // Remove previous listener if any, then add new one
                          saveScoreBtn.removeEventListener('click', saveHandler);
                          saveScoreBtn.addEventListener('click', saveHandler);
                    }
                }

            } else {
                // Fallback if game over screen element is missing
                alert(`Game Over! Final Score: ${score}`);
            }
        }


        function levelComplete() {
             // Prevent multiple calls if already processing
             if (levelCompleteScreen.style.display === "flex") return;

             debug(`Level ${level} complete!`);
             gameStarted = false; // Temporarily stop game loop
             playSound('levelComplete');
             stopMusic(); // Stop music between levels
             if (powerupActive) deactivatePowerup(); // Clean up powerups

             if (levelCompleteScreen) {
                 levelCompleteScreen.style.display = "flex";

                 // Format time spent on this level (needs tracking per level)
                 // Simple placeholder for now: use total game time
                 let levelSeconds = Math.floor(gameTime / 1000); // Needs refinement for per-level time
                 let levelMinutes = Math.floor(levelSeconds / 60);
                 levelSeconds %= 60;
                 let levelTimeString = `${levelMinutes}m ${levelSeconds.toString().padStart(2, '0')}s`;

                 // Calculate bonus points
                 let timeBonus = Math.max(0, 3000 - levelSeconds * 10); // Bonus decreases with time taken
                 let lifeBonus = lives * 150; // Bonus per remaining life
                 let levelClearBonus = level * 500; // Bonus for clearing the level
                 let comboBonus = maxCombo * 50; // Bonus for max combo achieved
                 let totalBonus = timeBonus + lifeBonus + levelClearBonus + comboBonus;
                 score += totalBonus; // Add bonus to total score

                 if (levelScoreDisplay) {
                     levelScoreDisplay.textContent = `Score: ${score} (+${totalBonus} Bonus)`;
                 }
                 if (levelStatsDisplay) {
                     levelStatsDisplay.innerHTML = `
                         Level ${level} Stats:<br>
                         Bricks Destroyed: ${bricksHit}/${totalBricks}<br>
                         Paddle Hits: ${paddleHits}<br>
                         Max Combo: x${maxCombo}<br>
                         Lives Remaining: ${lives}<br>
                         --- Bonus ---<br>
                         Time: +${timeBonus}<br>
                         Lives: +${lifeBonus}<br>
                         Clear: +${levelClearBonus}<br>
                         Combo: +${comboBonus}
                     `;
                 }
                 // Update main score display as well
                 if (scoreDisplay) scoreDisplay.textContent = `Score: ${score}`;

                 // Reset per-level stats for next level
                 maxCombo = 0;
                 paddleHits = 0;
                 // gameTime needs better per-level tracking if time bonus is precise

             } else {
                 // Fallback if screen element is missing
                 alert(`Level ${level} Complete! Score: ${score}`);
                 // Proceed to next level automatically if screen missing
                 setTimeout(nextLevel, 1000); // Add a small delay
             }
        }

        // --- Event Listener Setup ---

        function setupButtonListeners() {
            debug("Setting up button listeners...");

             const setupListener = (id, action, actionName) => {
                 const button = document.getElementById(id);
                 if (button) {
                     button.addEventListener("click", () => {
                         debug(`${actionName} button clicked`);
                         action();
                     });
                 } else {
                     debug(`Warning: Button with ID '${id}' not found.`);
                 }
             };

            // Start button
            setupListener("start-button", startGame, "Start Game");

             // Restart button (on Game Over screen)
             setupListener("restart-button", restartGame, "Restart Game (Game Over)");

             // Next level button
             setupListener("next-level-button", nextLevel, "Next Level");

             // High scores button (on Start screen)
             const highScoresButton = document.getElementById("high-scores-button");
             if (highScoresButton) {
                 highScoresButton.addEventListener("click", () => {
                     debug("High scores button clicked (from Start)");
                     displayHighScores();
                     const hsScreen = document.getElementById("high-scores");
                     const startScr = document.getElementById("start-screen");
                     if (hsScreen) hsScreen.style.display = "flex";
                     if (startScr) startScr.style.display = "none";
                 });
             } else { debug("Warning: Button with ID 'high-scores-button' not found."); }


             // Show scores button (on Game Over screen)
             const showScoresButton = document.getElementById("show-scores-button");
             if (showScoresButton) {
                  showScoresButton.addEventListener("click", () => {
                      debug("Show scores button clicked (from Game Over)");
                      displayHighScores();
                      const hsScreen = document.getElementById('high-scores');
                      const goScreen = document.getElementById('game-over');
                      if (hsScreen) hsScreen.style.display = 'flex';
                      if (goScreen) goScreen.style.display = 'none'; // Hide game over screen
                  });
             } else { debug("Warning: Button with ID 'show-scores-button' not found."); }


             // Back button (from High Scores screen)
             const backButton = document.getElementById("back-button");
             if (backButton) {
                 backButton.addEventListener("click", () => {
                     debug("Back button clicked (from High Scores)");
                      const hsScreen = document.getElementById("high-scores");
                      const startScr = document.getElementById("start-screen");
                     if (hsScreen) hsScreen.style.display = "none";
                      // Show start screen again, assume coming from start screen context
                      if (startScr) startScr.style.display = "flex";
                 });
             } else { debug("Warning: Button with ID 'back-button' not found."); }


             // --- Menu Button and Items ---
            const menuBtn = document.getElementById("menu-btn");
            const gameMenu = document.getElementById("game-menu");
            if (menuBtn && gameMenu) {
                menuBtn.addEventListener("click", (e) => {
                     e.stopPropagation(); // Prevent click from closing menu immediately
                    const isVisible = gameMenu.style.display === "block";
                    gameMenu.style.display = isVisible ? "none" : "block";
                    debug(`Menu toggled ${!isVisible ? 'ON' : 'OFF'}`);
                });

                 // Close menu if clicking outside
                 document.addEventListener('click', (e) => {
                     if (gameMenu.style.display === 'block' && !gameMenu.contains(e.target) && e.target !== menuBtn) {
                         gameMenu.style.display = 'none';
                         debug("Menu closed due to outside click.");
                     }
                 });

                 // Menu item actions
                 const setupMenuItem = (id, action, actionName) => {
                     const item = document.getElementById(id);
                     if (item) {
                         item.addEventListener('click', () => {
                             debug(`Menu item clicked: ${actionName}`);
                             action();
                             gameMenu.style.display = 'none'; // Close menu after action
                         });
                     } else { debug(`Warning: Menu item with ID '${id}' not found.`); }
                 };

                 setupMenuItem('toggle-sound', toggleSound, 'Toggle Sound');
                 setupMenuItem('toggle-music', toggleMusic, 'Toggle Music');
                 setupMenuItem('toggle-fullscreen', toggleFullscreen, 'Toggle Fullscreen');
                 setupMenuItem('restart-from-menu', () => {
                     if (gameStarted) restartGame(); else startGame();
                 }, 'Restart');

                 const showHighScoresItem = document.getElementById("show-high-scores");
                 if (showHighScoresItem) {
                     showHighScoresItem.addEventListener("click", () => {
                         debug("Menu item clicked: Show High Scores");
                          displayHighScores();
                          const hsScreen = document.getElementById("high-scores");
                          if (hsScreen) hsScreen.style.display = "flex";
                          gameMenu.style.display = 'none';
                          // Pause game if showing high scores mid-game
                          if (gameStarted && !gamePaused) {
                              togglePause();
                          }
                          // Hide other screens potentially? Or handle context better.
                           if (startScreen) startScreen.style.display = 'none';
                           if (gameOverScreen) gameOverScreen.style.display = 'none';
                           if (levelCompleteScreen) levelCompleteScreen.style.display = 'none';
                     });
                 } else { debug("Warning: Menu item with ID 'show-high-scores' not found."); }

            } else {
                 debug("Warning: Menu button or game menu element not found.");
             }


            // --- Theme Selectors ---
            const themeButtons = document.querySelectorAll('.theme-btn');
            if (themeButtons.length > 0) {
                 themeButtons.forEach(button => {
                      button.addEventListener('click', () => {
                          const themeId = button.id.replace('-theme', ''); // Extract theme name from ID
                          setTheme(themeId);
                      });
                  });
            } else {
                 debug("Warning: Theme buttons not found.");
             }
        }

        // Set theme function
        function setTheme(themeId) {
             // Check if theme exists
             if (!themes[themeId]) {
                 debug(`Warning: Theme '${themeId}' not found. Keeping '${currentTheme}'.`);
                 return;
             }
            currentTheme = themeId;
             debug(`Theme changed to: ${currentTheme}`);

            // Update active class on buttons
            document.querySelectorAll('.theme-btn').forEach(btn => {
                btn.classList.remove('active');
            });
             const activeBtn = document.getElementById(`${currentTheme}-theme`);
            if (activeBtn) activeBtn.classList.add('active');

             // Update dynamic background colors if needed (e.g., start screen)
            if (startScreen) {
                startScreen.style.backgroundColor = themes[currentTheme].screen.bg;
            }
             // Force redraw if game is running to apply new colors immediately?
             // No, draw loop handles colors dynamically based on currentTheme.
        }

        // Handle window resize - basic centering or scaling
        function handleResize() {
            // This is basic, more complex scaling might be needed for true responsiveness
            if (canvas) {
                 const container = document.getElementById('game-container');
                 if (container) {
                      // Example: Keep aspect ratio (800x600) and center
                      const containerWidth = container.offsetWidth;
                      const containerHeight = container.offsetHeight;
                      const scale = Math.min(containerWidth / 800, containerHeight / 600);

                      canvas.style.width = `${800 * scale}px`;
                      canvas.style.height = `${600 * scale}px`;
                      // Centering requires flexbox/grid on parent or absolute positioning math
                      debug(`Resized canvas visually to ${canvas.style.width} x ${canvas.style.height}`);
                 }
             }
        }


        // Initialize game on page load
        window.addEventListener("load", function() {
            console.log("Window loaded."); // Use console.log before debug is confirmed ready
            // Load high scores first
            loadHighScores();

            // Initialize game elements
            if (initializeElements()) {
                 console.log("Elements initialized.");
                 // Create starry background after canvas is ready
                 createStars();

                 // Set up button listeners
                 setupButtonListeners();

                 // Set up mobile controls (checks internally if needed)
                 setupMobileControls();

                 // Add global event listeners for keyboard input
                 document.addEventListener("keydown", keyDownHandler, false);
                 document.addEventListener("keyup", keyUpHandler, false);

                 // Add mouse listener (consider adding to canvas only?)
                 // Using document allows catching mouse even if slightly outside canvas during fast moves
                 document.addEventListener("mousemove", mouseMoveHandler, false);

                 // Handle window resize
                 window.addEventListener('resize', handleResize);
                 handleResize(); // Initial call to set size

                 // Set initial theme display
                 setTheme(currentTheme); // Applies default 'standard' or saved theme preference

                 debug("Game loaded and ready. Displaying start screen."); // Debug should work now
                 if(startScreen) startScreen.style.display = 'flex'; // Ensure start screen is shown

            } else {
                console.error("FATAL: Failed to initialize game elements! Game cannot start.");
                 alert("Error: Could not initialize game. Please check the console (F12) and reload.");
            }
        });

         // Optional: Fallback global click handler (less robust than specific listeners)
         /*
         document.addEventListener("click", function(e) {
             if (!e.target) return; // Basic check

             // Example: Handling specific button IDs if setupButtonListeners failed
             if (e.target.id === "start-button") {
                 debug("Start button clicked via GLOBAL handler (fallback)");
                 if (!gameStarted) startGame();
             } else if (e.target.id === "restart-button") {
                 debug("Restart button clicked via GLOBAL handler (fallback)");
                 if (gameOverScreen.style.display === 'flex') restartGame();
             } // etc.
         });
         */

    </script>
</body>
</html>
